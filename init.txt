# TABLE OF CONTENTS:
#
# SECTION A: Crawl options.
#            Self explanatory.
#
# SECTION B: Strategy functions.
#            These fucntions implement specific strategies, such as:
#            Quaff ID a potion. Travel to the lair. Rest. Progress.
#            More general strategies might call on more specific strategies
#            acording to the strategy tables.
#
# SECTION C: Strategy tables.
#            These tables govern which strategies have priority over which
#            other strategies. For instance you would rather berserk than
#            attack. However if there's no reason to beserk (because the
#            situation doesn't pose enough of a threat) or if you can't go
#            berserk for some reason, then attacking normally will be your
#            fall back plan.
#
#            If you're like to change the route (orc before lair for instance)
#            or some other simplistic strategy change, then you may be able to
#            do it here without having to be much of a programmer.
#
# SECTION D: Main functions.
#            These functions include "hit_closest()" which is called when you
#            press TAB. As well as "ready()" which is called when Crawl is
#            ready to accept user input. In addition the heartbeat function
#            "cb_main()" is included. These functions drive the bot, and are
#            the entry points to everything else, so if you're curious how cb
#            works, then this is the place you want to start reading.
#
# SECTION E: Autopickup functions.
#            These functions control cb's dynamic autopickup functionality.
#            There is the "autopickup()" entry point as well as related
#            functions needed for item prioritization.
#
# SECTION F: Utility functions.
#            These functions are called by all the above functions. They
#            include general stuff used everywhere like "say(message)" which
#            is called all over the place for feedback and debugging. As well
#            as some functions that may only be used by one or two strategies.

view_delay = 0
use_animations =
clear_messages = true
travel_delay = -1
explore_delay = -1
travel_key_stop = false
default_manual_training = true
autopickup_no_burden = false
auto_exclude =
hp_warning = 0
show_more = false
show_newturn_mark = false
list_rotten = false
force_more_message =
show_travel_trail = false
skill_focus = false
autoinscribe += slay:mikee
flush.failure = false
char_set = ascii
cset = cloud:xa4
cset = item_orb:0
use_fake_player_cursor = true
equip_unequip = true

dump_order = header,hiscore,stats,misc,mutations,skills,spells,inventory
dump_order += overview
dump_order += messages,screenshot,monlist,kills,notes,vaults,action_counts
ood_interesting = 6
note_hp_percent = 25
note_skill_levels = 1,3,6,9,12,15,18,21,24,27
note_all_spells = true

# TBD...
fire_order = launcher, rock, javelin, tomahawk

####################################
# not sure exactly how important or correct these settings are

explore_stop =
explore_stop += items,branches,portals,stairs,altars
explore_stop += greedy_visited_item_stack,greedy_pickup_smart

stop := runrest_stop_message
ignore := runrest_ignore_message
stop =
ignore =
ignore += .*

runrest_ignore_poison = 3:15
runrest_ignore_monster += butterfly:1
runrest_ignore_monster += orb of destruction:1

####################################
# These keys are useful to answer prompts and aren't critical for manual play

bindkey = [Y] CMD_NO_CMD_DEFAULT
bindkey = [N] CMD_NO_CMD_DEFAULT
bindkey = [B] CMD_NO_CMD_DEFAULT
bindkey = [.] CMD_NO_CMD_DEFAULT

####################################
# Don't get interrupted!
: chk_interrupt_activity["blurry vision"] = function (iname, cause, extra)
:   return nil
: end

####################################
# autopickup/drop_filter stuff, just used for scrolls/potions/wands

autopickup = ?!/

ae := autopickup_exceptions
df := drop_filter
ae =
df =
# keep: identify,teleportation,remove curse,enchant weapon,
#       enchant armour,acquirement,recharging,holy word
ae += scrolls? of (summoning|vulnerability|brand weapon)
ae += scrolls? of (magic mapping|fog|fear|silence)
ae += scrolls? of (blinking|amnesia)
ae += scrolls? of (curse armour|curse jewellery|curse weapon)
ae += scrolls? of (immolation|noise|random uselessness|torment)
df += scrolls? of (summoning|vulnerability|brand weapon)
df += scrolls? of (magic mapping|fog|fear|silence)
df += scrolls? of (blinking|amnesia)
df += scrolls? of (curse armour|curse jewellery|curse weapon)
df += scrolls? of (immolation|noise|random uselessness|torment)
# keep: curing,heal wounds,haste,cancellation,resistance,experience,
#       might,beneficial mutation,cure mutation,restore abilities
ae += potions? of (brilliance|magic|berserk rage)
ae += potions? of (flight|invisibility|agility)
ae += potions? of (ambrosia|decay|degeneration|mutation)
ae += potions? of (poison|lignification)
df += potions? of (brilliance|magic|berserk rage)
df += potions? of (flight|invisibility|agility)
df += potions? of (ambrosia|decay|degeneration|mutation)
df += potions? of (poison|lignification)
: if you.race() ~= "Vampire" then
ae += potions? of blood
df += potions? of blood
: end
# keep: heal wounds,hasting,teleportation
ae += wand of (random effects|slowing|magic darts|flame|frost|confusion)
ae += wand of (enslavement|paralysis|invisibility|lightning|fireball)
ae += wand of (cold|digging|disintegration|draining|fire|polymorph)
df += wand of (random effects|slowing|magic darts|flame|frost|confusion)
df += wand of (enslavement|paralysis|invisibility|lightning|fireball)
df += wand of (cold|digging|disintegration|draining|fire|polymorph)

################################################################
# now the lua

{

local LOS = 7

local current_turn

-- cb takes action, spending one or more turns.
-- Hopefully this brings us closer to victory!
function cb_main()
  do_it("o")
end

local cb = coroutine.create(cb_main)

-- hit_closest is run when you press tab.
local first_time = true

function hit_closest()
  if(not first_time) then
    if(coroutine.status(cb) == "dead") then
      cb = coroutine.create(cb_main)
      coroutine.resume(cb)
    end
  else
    coroutine.resume(cb)
    first_time = false
  end
end

-- ready is run when crawl is ready for user input.
function ready()
  current_turn = you.turns()
  if(not first_time and coroutine.status(cb) == "suspended") then
    coroutine.resume(cb)
  end
end

function do_it(command)
  local old_turn = you.turns()
  crawl.process_keys(command)
  -- We yield, waiting for us to be ready to accept input again.
  -- When we're ready again, the current_turn may be different.
  coroutine.yield()
  if(current_turn == old_turn) then
    say("BUG: The action \"" .. command .. "\" failed unexpectedly.")
  end
end

function try_it(command)
  local old_turn = you.turns()
  crawl.process_keys(command)
  -- We yield, waiting for us to be ready to accept input again.
  -- When we're ready again, the current_turn may be different.
  coroutine.yield()
  if(current_turn == old_turn) then
    return false
  end
  return true
end

function say(x)
  crawl.mpr(x)
  crawl.take_note(x)
end

}
